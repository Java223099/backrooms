<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced First Person Maze Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #sensitivity-container {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-size: 16px;
        }
        #screamer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #screamer img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #power-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="ui">Score: <span id="score">0</span> | Health: <span id="health">100</span></div>
    <div id="crosshair"></div>
    <div id="sensitivity-container">
        Mouse Sensitivity: <input type="range" id="mouseSensitivity" min="0.5" max="3" step="0.1" value="1">
    </div>
    <div id="screamer">
        <img id="screamer-img" src="" alt="Screamer">
    </div>
    <div id="power-ui"></div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Инициализация сцены
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xadd8e6);
        scene.fog = new THREE.FogExp2(0xadd8e6, 0.001);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Управление PointerLockControls
        const controls = new PointerLockControls(camera, renderer.domElement);
        document.addEventListener('click', () => {
            controls.lock();
        });
        controls.addEventListener('lock', () => {
            document.getElementById('crosshair').style.display = 'block';
        });
        controls.addEventListener('unlock', () => {
            document.getElementById('crosshair').style.display = 'none';
        });

        // Настройка чувствительности мыши
        let mouseSensitivity = 1;
        const mouseSensitivitySlider = document.getElementById('mouseSensitivity');

        // Переопределение onMouseMove для учета чувствительности
        const PI_2 = Math.PI / 2;
        const changeEvent = { type: 'change' };
        controls.onMouseMove = function (event) {
            if (this.enabled === false) return;

            let movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            let movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            movementX *= mouseSensitivity;
            movementY *= mouseSensitivity;

            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(camera.quaternion);

            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;

            euler.x = Math.max(PI_2 - this.maxPolarAngle, Math.min(PI_2 - this.minPolarAngle, euler.x));

            camera.quaternion.setFromEuler(euler);

            this.dispatchEvent(changeEvent);
        };

        // Параметры игрока
        const player = {
            position: new THREE.Vector3(0, 1.5, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.5, // Decreased speed
            score: 0,
            health: 100
        };
        let onGround = true;
        let walkTime = 0;
        let firstDamage = true;

        // Массив скримеров
        const screamerImages = [
            'https://www.watchmojo.com/uploads/thumbs720/VG-RP-Top10-Jump-Scares-In-Videogames-720p30.jpg',
            'https://www.watchmojo.com/uploads/thumbs720/MP-10-Scariest-Moments-in-Silent-Hill_Z6U4Z8-V3.webp',
            'https://i.ytimg.com/vi/l_1EwIIcTks/sddefault.jpg',
            'https://cdn.mos.cms.futurecdn.net/v2/t:0,l:140,cw:1069,ch:802,q:80,w:1069/g3oRWf7ptRJgnvsw2v8fyS.jpg',
            'https://hard-drive.net/wp-content/uploads/2023/12/Listicle-Thumbnail2.jpg.webp'
        ];

        // Управление клавишами
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Ноги игрока
        const body = new THREE.Group();
        const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0 });
        const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 32);
        const leftLeg = new THREE.Mesh(legGeo, legMaterial);
        leftLeg.position.set(-0.2, -0.4, 0);
        body.add(leftLeg);
        const rightLeg = new THREE.Mesh(legGeo, legMaterial);
        rightLeg.position.set(0.2, -0.4, 0);
        body.add(rightLeg);
        scene.add(body);

        // Увеличенный лабиринт
        const walls = [];
        const wallColor = 0x555555;
        const wallMaterial = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.5, metalness: 0 });
        const wallThin = 1; // Уменьшенная ширина стен

        // Внешние стены как длинные сегменты
        const externalWalls = [
            { geo: new THREE.BoxGeometry(320, 4, wallThin), pos: [0, 2, -150] }, // Нижняя
            { geo: new THREE.BoxGeometry(320, 4, wallThin), pos: [0, 2, 150] },  // Верхняя
            { geo: new THREE.BoxGeometry(wallThin, 4, 320), pos: [-150, 2, 0] }, // Левая
            { geo: new THREE.BoxGeometry(wallThin, 4, 320), pos: [150, 2, 0] }   // Правая
        ];

        externalWalls.forEach(w => {
            const wall = new THREE.Mesh(w.geo, wallMaterial);
            wall.position.set(...w.pos);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        });

        // Внутренние стены с разными длинами (детерминистично, добавлено больше)
        const wallPositions = [
            [0, 0, -100], [0, 0, 100], [-100, 0, 0], [100, 0, 0],
            [50, 0, -50], [50, 0, 50], [-50, 0, -50], [-50, 0, 50],
            [20, 0, -80], [20, 0, 80], [-20, 0, -80], [-20, 0, 80],
            [80, 0, -20], [80, 0, 20], [-80, 0, -20], [-80, 0, 20],
            [0, 0, -40], [0, 0, 40], [40, 0, 0], [-40, 0, 0],
            [120, 0, -100], [120, 0, 100], [-120, 0, -100], [-120, 0, 100],
            [100, 0, -120], [100, 0, 120], [-100, 0, -120], [-100, 0, 120],
            // Добавленные стены
            [30, 0, -60], [30, 0, 60], [-30, 0, -60], [-30, 0, 60],
            [60, 0, -30], [60, 0, 30], [-60, 0, -30], [-60, 0, 30],
            [10, 0, -90], [10, 0, 90], [-10, 0, -90], [-10, 0, 90],
            [90, 0, -10], [90, 0, 10], [-90, 0, -10], [-90, 0, 10],
            [0, 0, -50], [0, 0, 50], [50, 0, 0], [-50, 0, 0],
            [110, 0, -90], [110, 0, 90], [-110, 0, -90], [-110, 0, 90],
            [90, 0, -110], [90, 0, 110], [-90, 0, -110], [-90, 0, 110],
            [70, 0, -40], [70, 0, 40], [-70, 0, -40], [-70, 0, 40],
            [40, 0, -70], [40, 0, 70], [-40, 0, -70], [-40, 0, 70],
            [130, 0, -60], [130, 0, 60], [-130, 0, -60], [-130, 0, 60],
            [60, 0, -130], [60, 0, 130], [-60, 0, -130], [-60, 0, 130]
        ];

        wallPositions.forEach((pos, i) => {
            const lengthIndex = (Math.abs(pos[0]) + Math.abs(pos[2])) % 4;
            const length = 40 + lengthIndex * 20; // Scaled
            const isHorizontal = Math.abs(pos[0]) >= Math.abs(pos[2]);
            let geo;
            if (isHorizontal) {
                geo = new THREE.BoxGeometry(length, 4, wallThin);
            } else {
                geo = new THREE.BoxGeometry(wallThin, 4, length);
            }
            const wall = new THREE.Mesh(geo, wallMaterial);
            wall.position.set(pos[0], pos[1] + 2, pos[2]);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        });

        // Пол
        const floorGeometry = new THREE.PlaneGeometry(400, 400);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.7, metalness: 0, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Монеты (золотой цвет)
        const coins = [];
        const coinGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const coinMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1, metalness: 1 });

        const coinPositions = [
            [10, 1.5, 10], [-10, 1.5, -10], [30, 1.5, 30], [-30, 1.5, -30],
            [0, 1.5, 80], [80, 1.5, 0], [-80, 1.5, 0], [0, 1.5, -80],
            [100, 1.5, 100], [-100, 1.5, -100], [100, 1.5, -100], [-100, 1.5, 100],
            [50, 1.5, 70], [-50, 1.5, -70], [70, 1.5, -50], [-70, 1.5, 50],
            [120, 1.5, 20], [-120, 1.5, -20], [20, 1.5, 120], [-20, 1.5, -120]
        ];

        coinPositions.forEach(pos => {
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.set(pos[0], pos[1], pos[2]);
            coin.castShadow = true;
            scene.add(coin);
            coins.push(coin);
        });

        // Фрукты
        const fruits = [];
        const fruitGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const fruitMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });

        const fruitPositions = [
            [40, 1.5, 40], [-40, 1.5, -40], [60, 1.5, 60], [-60, 1.5, -60],
            [10, 1.5, 90], [90, 1.5, 10], [-90, 1.5, 10], [10, 1.5, -90],
            [110, 1.5, 110], [-110, 1.5, -110], [110, 1.5, -110], [-110, 1.5, 110]
        ];

        fruitPositions.forEach(pos => {
            const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
            fruit.position.set(pos[0], pos[1], pos[2]);
            fruit.castShadow = true;
            scene.add(fruit);
            fruits.push(fruit);
        });

        // Черные круглые кубики (сферы)
        const blackSpheres = [];
        const blackSphereGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const blackSphereMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5, metalness: 0 });
        const blackSpherePositions = [
            [15, 1.5, 15], [-15, 1.5, -15], [35, 1.5, 35], [-35, 1.5, -35],
            [5, 1.5, 85], [85, 1.5, 5], [-85, 1.5, 5], [5, 1.5, -85],
            [105, 1.5, 105], [-105, 1.5, -105], [105, 1.5, -105], [-105, 1.5, 105],
            [55, 1.5, 75], [-55, 1.5, -75], [75, 1.5, -55], [-75, 1.5, 55],
            [125, 1.5, 25], [-125, 1.5, -25], [25, 1.5, 125], [-25, 1.5, -125],
            [45, 1.5, 45], [-45, 1.5, -45], [65, 1.5, 65], [-65, 1.5, -65],
            [15, 1.5, 95], [95, 1.5, 15], [-95, 1.5, 15], [15, 1.5, -95],
            [115, 1.5, 115], [-115, 1.5, -115], [115, 1.5, -115], [-115, 1.5, 115],
            [0, 1.5, 0], [130, 1.5, 130], [-130, 1.5, -130]
        ];

        blackSpherePositions.slice(0, 20).forEach(pos => { // 20 черных сфер
            const sphere = new THREE.Mesh(blackSphereGeometry, blackSphereMaterial);
            sphere.position.set(pos[0], pos[1], pos[2]);
            sphere.castShadow = true;
            scene.add(sphere);
            blackSpheres.push(sphere);
        });

        // Функция для создания реалистичного персонажа
        function createCharacter(color) {
            const group = new THREE.Group();
            // Тело
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
            const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0 });
            const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
            bodyMesh.position.y = 0.75;
            group.add(bodyMesh);
            // Голова
            const headGeo = new THREE.SphereGeometry(0.4, 32, 32);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5, metalness: 0 });
            const headMesh = new THREE.Mesh(headGeo, headMat);
            headMesh.position.y = 1.75;
            group.add(headMesh);
            // Ноги
            const legGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 32);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0 });
            const leftLegMesh = new THREE.Mesh(legGeo, legMat);
            leftLegMesh.position.set(-0.25, -0.5, 0);
            group.add(leftLegMesh);
            const rightLegMesh = new THREE.Mesh(legGeo, legMat);
            rightLegMesh.position.set(0.25, -0.5, 0);
            group.add(rightLegMesh);
            group.castShadow = true;
            return group;
        }

        // Враги
        const enemies = [];
        const enemyPositions = [
            [70, 0, 70], [-70, 0, -70], [130, 0, 130], [-130, 0, -130],
            [100, 0, -100], [-100, 0, 100], [140, 0, 50], [-140, 0, -50]
        ];

        enemyPositions.forEach(pos => {
            const enemy = createCharacter(0xff0000); // Красный для врагов
            enemy.position.set(pos[0], pos[1] + 1, pos[2]);
            enemy.userData = { hits: 0, lastAttackTime: 0, velocity: new THREE.Vector3() };
            scene.add(enemy);
            enemies.push(enemy);
        });

        // Помощники (увеличено количество)
        const helpers = [];
        const helperPositions = [
            [50, 0, -100], [-50, 0, 100], [120, 0, -50], [-120, 0, 50],
            [30, 0, -120], [-30, 0, 120], [100, 0, -70], [-100, 0, 70],
            [80, 0, -90], [-80, 0, 90], [140, 0, -30], [-140, 0, 30],
            [60, 0, -110], [-60, 0, 110], [110, 0, -60], [-110, 0, 60]
        ];

        helperPositions.forEach(pos => {
            const helper = createCharacter(0x00ff00); // Зеленый для помощников
            helper.position.set(pos[0], pos[1] + 1, pos[2]);
            helper.userData = { velocity: new THREE.Vector3(), greenCubesGiven: 0, superCubeGiven: false };
            scene.add(helper);
            helpers.push(helper);
        });

        // Зеленые кубики
        const greenCubes = [];
        const greenCubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const greenCubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.5, metalness: 0 });

        // Суперкубики
        const superCubes = [];
        const superCubeGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
        const superCubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.1, metalness: 1 });

        // Способности суперкубика
        const superPowers = [
            'fly', // Летать 30 сек
            'invincible', // Не получать урон 30 сек
            'freezeEnemies', // Противники не двигаются 30 сек
            'highJump' // Высокий прыжок 30 сек
            // Можно добавить другие
        ];

        let activePower = null;
        let powerStartTime = 0;

        // Лагерь с торговцем
        const traderPosition = new THREE.Vector3(140, 1, 140);
        const trader = createCharacter(0x0000ff); // Синий для торговца
        trader.position.copy(traderPosition);
        scene.add(trader);

        // Освещение
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
        scene.add(hemiLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -200;
        directionalLight.shadow.camera.right = 200;
        directionalLight.shadow.camera.top = 200;
        directionalLight.shadow.camera.bottom = -200;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 400;
        scene.add(directionalLight);

        // Проверка столкновений для персонажей
        function characterCollision(newPosition) {
            const charBox = new THREE.Box3().setFromCenterAndSize(
                newPosition,
                new THREE.Vector3(1, 2, 1)
            );
            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (charBox.intersectsBox(wallBox)) {
                    return true;
                }
            }
            return false;
        }

        // Проверка столкновений
        function checkCollision(newPosition) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                newPosition,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) {
                    return true;
                }
            }
            return false;
        }

        // Проверка сбора монет
        function checkCoins() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            coins.forEach((coin, index) => {
                const coinBox = new THREE.Box3().setFromObject(coin);
                if (playerBox.intersectsBox(coinBox)) {
                    scene.remove(coin);
                    coins.splice(index, 1);
                    player.score += 1;
                    document.getElementById('score').innerText = player.score;
                }
            });
        }

        // Проверка сбора фруктов
        function checkFruits() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            fruits.forEach((fruit, index) => {
                const fruitBox = new THREE.Box3().setFromObject(fruit);
                if (playerBox.intersectsBox(fruitBox)) {
                    scene.remove(fruit);
                    fruits.splice(index, 1);
                    player.health = Math.min(player.health + 20, 100);
                    document.getElementById('health').innerText = player.health;
                }
            });
        }

        // Проверка сбора зеленых кубиков
        function checkGreenCubes() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            greenCubes.forEach((cube, index) => {
                const cubeBox = new THREE.Box3().setFromObject(cube);
                if (playerBox.intersectsBox(cubeBox)) {
                    scene.remove(cube);
                    greenCubes.splice(index, 1);
                    player.health = Math.min(player.health + 10, 100); // Пример эффекта
                    document.getElementById('health').innerText = player.health;
                }
            });
        }

        // Проверка сбора суперкубиков
        function checkSuperCubes() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            superCubes.forEach((cube, index) => {
                const cubeBox = new THREE.Box3().setFromObject(cube);
                if (playerBox.intersectsBox(cubeBox)) {
                    scene.remove(cube);
                    superCubes.splice(index, 1);
                    activePower = superPowers[Math.floor(Math.random() * superPowers.length)];
                    powerStartTime = performance.now();
                    updatePowerUI();
                }
            });
        }

        // Проверка сбора черных сфер
        function checkBlackSpheres() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            blackSpheres.forEach((sphere, index) => {
                const sphereBox = new THREE.Box3().setFromObject(sphere);
                if (playerBox.intersectsBox(sphereBox)) {
                    scene.remove(sphere);
                    blackSpheres.splice(index, 1);
                    player.score += 1; // Используем score для подсчета черных сфер
                    document.getElementById('score').innerText = player.score;
                }
            });
        }

        // Логика врагов
        function updateEnemies() {
            const currentTime = performance.now();
            enemies.forEach((enemy, index) => {
                const distance = camera.position.distanceTo(enemy.position);
                if (distance < 5 && currentTime - enemy.userData.lastAttackTime > 1000) { // Атака раз в секунду
                    if (activePower !== 'invincible') {
                        player.health -= 10;
                        document.getElementById('health').innerText = player.health;
                    }
                    enemy.userData.hits += 1;
                    enemy.userData.lastAttackTime = currentTime;
                    if (firstDamage) {
                        // Показать скример
                        const randomImage = screamerImages[Math.floor(Math.random() * screamerImages.length)];
                        document.getElementById('screamer-img').src = randomImage;
                        document.getElementById('screamer').style.display = 'flex';
                        setTimeout(() => {
                            document.getElementById('screamer').style.display = 'none';
                        }, 500);
                        firstDamage = false;
                    }
                    if (enemy.userData.hits >= 2) {
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                    }
                }

                // Движение врага
                if (activePower !== 'freezeEnemies') {
                    let direction = new THREE.Vector3();
                    if (distance < 50) {
                        // Двигаться к игроку
                        direction.subVectors(camera.position, enemy.position).normalize();
                    } else {
                        // Случайное движение
                        direction.x = Math.random() * 2 - 1;
                        direction.z = Math.random() * 2 - 1;
                        direction.normalize();
                    }
                    const newPos = enemy.position.clone().add(direction.multiplyScalar(0.05)); // Медленное движение
                    if (!characterCollision(newPos)) {
                        enemy.position.copy(newPos);
                    }
                }
            });
        }

        // Логика помощников (приносят фрукты)
        function updateHelpers() {
            helpers.forEach(helper => {
                const distance = camera.position.distanceTo(helper.position);
                if (distance < 10) {
                    if (helper.userData.greenCubesGiven < 3) {
                        // Дать зеленый кубик
                        const cube = new THREE.Mesh(greenCubeGeometry, greenCubeMaterial);
                        cube.position.copy(camera.position);
                        cube.position.y = 1.5;
                        cube.position.x += Math.random() * 2 - 1;
                        cube.position.z += Math.random() * 2 - 1;
                        scene.add(cube);
                        greenCubes.push(cube);
                        helper.userData.greenCubesGiven += 1;
                    } else if (!helper.userData.superCubeGiven) {
                        // Дать суперкубик
                        const cube = new THREE.Mesh(superCubeGeometry, superCubeMaterial);
                        cube.position.copy(camera.position);
                        cube.position.y = 1.5;
                        cube.position.x += Math.random() * 2 - 1;
                        cube.position.z += Math.random() * 2 - 1;
                        scene.add(cube);
                        superCubes.push(cube);
                        helper.userData.superCubeGiven = true;
                    }
                }

                // Движение помощника
                const direction = new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize();
                const newPos = helper.position.clone().add(direction.multiplyScalar(0.03)); // Медленное движение
                if (!characterCollision(newPos)) {
                    helper.position.copy(newPos);
                }
            });
        }

        // Логика торговца
        function checkTrader() {
            const distance = camera.position.distanceTo(traderPosition);
            if (distance < 5 && keys['KeyE'] && player.score >= 1) {
                player.score -= 1;
                document.getElementById('score').innerText = player.score;
                player.health = Math.min(player.health + 20, 100);
                document.getElementById('health').innerText = player.health;
            }
        }

        // Обновление способностей
        function updatePowers() {
            const currentTime = performance.now();
            if (activePower && currentTime < powerStartTime + 30000) {
                const remaining = Math.ceil((powerStartTime + 30000 - currentTime) / 1000);
                document.getElementById('power-ui').innerText = `${activePower} (${remaining}s)`;
                // Активна способность
                if (activePower === 'fly') {
                    if (keys['Space']) player.velocity.y = 0.1;
                    if (keys['ShiftLeft']) player.velocity.y = -0.1;
                } else if (activePower === 'highJump') {
                    if (keys['Space'] && onGround) player.velocity.y = 0.4; // Высокий прыжок
                }
                // Другие способности уже обработаны в updateEnemies
            } else {
                activePower = null;
                document.getElementById('power-ui').innerText = '';
            }
        }

        // Игровой цикл
        function animate() {
            requestAnimationFrame(animate);

            // Обновление чувствительности мыши
            mouseSensitivity = parseFloat(mouseSensitivitySlider.value);

            // Движение игрока
            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;

            // Прыжок
            if (keys['Space'] && onGround && activePower !== 'fly') {
                player.velocity.y = 0.2;
                onGround = false;
            }

            // Гравитация
            if (activePower !== 'fly') player.velocity.y -= 0.005;

            let moving = false;
            if (direction.length() > 0) {
                direction.normalize();
                direction.applyQuaternion(camera.quaternion);
                direction.y = 0;
                moving = true;
                walkTime += 0.05;

                // Поворот тела в направление движения
                body.rotation.y = Math.atan2(direction.x, direction.z);
            } else {
                walkTime += 0;
            }

            const newPosition = camera.position.clone().add(direction.multiplyScalar(player.speed));
            newPosition.y += player.velocity.y;

            if (!checkCollision(newPosition)) {
                camera.position.copy(newPosition);
            }

            if (camera.position.y <= 1.5 && activePower !== 'fly') {
                camera.position.y = 1.5;
                player.velocity.y = 0;
                onGround = true;
            }

            // Анимация ног и покачивание головы
            leftLeg.rotation.x = Math.sin(walkTime) * 0.5;
            rightLeg.rotation.x = Math.sin(walkTime + Math.PI) * 0.5;
            camera.position.y += Math.sin(walkTime) * 0.05; // Покачивание

            // Обновление позиции тела
            body.position.copy(camera.position);
            body.position.y -= 0.7;

            // Если не двигаемся, поворачиваем тело в направление взгляда
            if (!moving) {
                body.rotation.y = camera.rotation.y;
            }

            // Вращение монет
            coins.forEach(coin => {
                coin.rotation.y += 0.01;
            });

            // Проверка сбора монет и фруктов
            checkCoins();
            checkFruits();
            checkGreenCubes();
            checkSuperCubes();
            checkBlackSpheres();

            // Обновление врагов и помощников
            updateEnemies();
            updateHelpers();

            // Обновление способностей
            updatePowers();

            // Проверка торговца
            checkTrader();

            // Проверка здоровья
            if (player.health <= 0) {
                document.getElementById('ui').innerText = 'Game Over! Score: ' + player.score;
            }

            // Победа
            if (blackSpheres.length === 0) {
                document.getElementById('ui').innerText = 'You Win! Collected all black spheres!';
            }

            renderer.render(scene, camera);
        }

        // Обработка изменения размера окна
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Запуск игры
        camera.position.set(0, 1.5, 0);
        animate();
    </script>
</body>
</html>