<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Улучшенная игра в лабиринт от первого лица</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #sensitivity-container {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-size: 16px;
        }
        #screamer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #screamer img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #power-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
        }
        #black-ui {
            position: absolute;
            top: 40px;
            right: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
        }
        #instructions {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #instructions p {
            pointer-events: auto;
        }
        #shop {
            position: absolute;
            top: 20%;
            left: 20%;
            width: 60%;
            height: 60%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            display: none;
            z-index: 1000;
            overflow-y: auto;
        }
        #shop h2 {
            text-align: center;
        }
        #shop ul {
            list-style: none;
            padding: 0;
        }
        #shop li {
            margin: 10px 0;
        }
        #shop button {
            margin-left: 10px;
        }
        #close-shop {
            position: absolute;
            top: 10px;
            right: 10px;
            background: red;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
        }
        #rotate-message {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            color: white;
            text-align: center;
            padding-top: 40%;
            display: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="ui">Счёт: <span id="score">0</span> | Здоровье: <span id="health">100</span></div>
    <div id="crosshair" style="display: none;"></div>
    <div id="sensitivity-container">
        Чувствительность мыши: <input type="range" id="mouseSensitivity" min="0.5" max="3" step="0.1" value="1">
    </div>
    <div id="screamer">
        <img id="screamer-img" src="" alt="Screamer">
    </div>
    <div id="power-ui"></div>
    <div id="black-ui">Черные: 0/20</div>
    <div id="instructions">
        <p>Нажмите куда-нибудь, чтобы играть и заблокировать мышь.</p>
        <p>Если не работает, попробуйте запустить на локальном сервере (например, через Python's http.server) или в другом браузере. Блокировка указателя может быть ограничена в локальных файлах.</p>
        <p>Управление: WASD для движения, Пробел для прыжка, Мышь для взгляда, E для взаимодействия с торговцем, F для переключения фонарика.</p>
    </div>
    <div id="shop">
        <button id="close-shop">Закрыть</button>
        <h2>Магазин торговца</h2>
        <ul>
            <li>Улучшенный фонарик (3 черных кубика) <button onclick="buyItem('improvedFlashlight')">Купить</button></li>
            <li>Увеличение длительности способностей +5с (2 черных кубика) <button onclick="buyItem('powerDuration')">Купить</button></li>
            <li>Сапоги 2 уровня (Скорость +) (3 черных кубика) <button onclick="buyItem('boots2')">Купить</button></li>
            <li>Сапоги 3 уровня (Скорость ++) (4 черных кубика) <button onclick="buyItem('boots3')">Купить</button></li>
            <li>Супер сапоги (Супер скорость) (7 черных кубиков) <button onclick="buyItem('superBoots')">Купить</button></li>
            <li>Случайная способность (3 черных кубика) <button onclick="buyItem('randomPower')">Купить</button></li>
            <li>Зелье здоровья (+50 Здоровья) (2 черных кубика) <button onclick="buyItem('healthPotion')">Купить</button></li>
            <li>Зелье заморозки врагов (Заморозить всех врагов на 10с) (4 черных кубика) <button onclick="buyItem('freezePotion')">Купить</button></li>
            <li>Множитель монет (x2 монет на 30с) (3 черных кубика) <button onclick="buyItem('coinMultiplier')">Купить</button></li>
            <li>Зелье неуязвимости (Неуязвим на 15с) (5 черных кубиков) <button onclick="buyItem('invincibilityPotion')">Купить</button></li>
        </ul>
    </div>
    <div id="rotate-message">
        Пожалуйста, поверните устройство в горизонтальный режим для лучшего опыта.
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        // Инициализация сцены
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x111111, 0.002); // Reduced density for less fog
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        // Управление PointerLockControls
        const controls = new PointerLockControls(camera, document.body);
        // Handle pointer lock errors
        document.addEventListener('pointerlockerror', (event) => {
            console.error('Pointer Lock Error:', event);
            document.getElementById('instructions').innerHTML += '<p>Блокировка указателя не удалась. Проверьте консоль для деталей или попробуйте другой браузер/настройку.</p>';
        });
        // Override lock to handle promise rejection
        const originalLock = controls.lock.bind(controls);
        controls.lock = function() {
            const promise = originalLock();
            if (promise instanceof Promise) {
                promise.catch((err) => {
                    console.error('Pointer lock rejected:', err);
                });
            }
        };
        // Click to lock
        document.addEventListener('click', () => {
            if (!controls.isLocked) {
                controls.lock();
            }
        });
        const instructions = document.getElementById('instructions');
        controls.addEventListener('lock', () => {
            instructions.style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
        });
        controls.addEventListener('unlock', () => {
            instructions.style.display = 'flex';
            document.getElementById('crosshair').style.display = 'none';
        });
        // Настройка чувствительности мыши
        let mouseSensitivity = 1;
        const mouseSensitivitySlider = document.getElementById('mouseSensitivity');
        // Переопределение onMouseMove для учета чувствительности
        const PI_2 = Math.PI / 2;
        const changeEvent = { type: 'change' };
        controls.onMouseMove = function (event) {
            if (this.enabled === false) return;
            let movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            let movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            movementX *= mouseSensitivity;
            movementY *= mouseSensitivity;
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(PI_2 - this.maxPolarAngle, Math.min(PI_2 - this.minPolarAngle, euler.x));
            camera.quaternion.setFromEuler(euler);
            this.dispatchEvent(changeEvent);
        };
        // Параметры игрока
        const player = {
            position: new THREE.Vector3(0, 1.5, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.5,
            score: 0,
            health: 100,
            blackCollected: 0,
            powerDuration: 30000,
            flashlightLevel: 0,
            bootsLevel: 0,
            coinMultiplier: 1,
            coinMultiplierStart: 0
        };
        let onGround = true;
        let walkTime = 0;
        let firstDamage = true;
        // Фонарик
        const flashlight = new THREE.SpotLight(0xffffff, 0, 100, Math.PI/3, 0.5, 2);
        flashlight.castShadow = true;
        flashlight.shadow.mapSize.width = 1024;
        flashlight.shadow.mapSize.height = 1024;
        flashlight.position.set(0, 0, 0);
        const flashlightTarget = new THREE.Object3D();
        flashlightTarget.position.set(0, 0, -1);
        flashlight.target = flashlightTarget;
        camera.add(flashlight);
        camera.add(flashlightTarget);
        let flashlightOn = false;
        // Массив скримеров
        const screamerImages = [
            'https://www.watchmojo.com/uploads/thumbs720/VG-RP-Top10-Jump-Scares-In-Videogames-720p30.jpg',
            'https://www.watchmojo.com/uploads/thumbs720/MP-10-Scariest-Moments-in-Silent-Hill_Z6U4Z8-V3.webp',
            'https://i.ytimg.com/vi/l_1EwIIcTks/sddefault.jpg',
            'https://cdn.mos.cms.futurecdn.net/v2/t:0,l:140,cw:1069,ch:802,q:80,w:1069/g3oRWf7ptRJgnvsw2v8fyS.jpg',
            'https://i.ytimg.com/vi/yHr_Jm2hGig/hq720.jpg?sqp=-oaymwEhCK4FEIIDSFryq4qpAxMIARUAAAAAGAElAADIQj0AgKJD&rs=AOn4CLDBTmoKQS_kGXKqomUsfiFO8m7zCg'
        ];
        // Управление клавишами
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyF') {
                flashlightOn = !flashlightOn;
                updateFlashlight();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        // Обновление фонарика
        function updateFlashlight() {
            if (flashlightOn) {
                flashlight.intensity = 2 + player.flashlightLevel * 1;
                flashlight.distance = 100 + player.flashlightLevel * 50;
                flashlight.angle = Math.PI/3 + player.flashlightLevel * (Math.PI/10);
            } else {
                flashlight.intensity = 0;
            }
        }
        // Ноги игрока
        const body = new THREE.Group();
        const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0 });
        const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 32);
        const leftLeg = new THREE.Mesh(legGeo, legMaterial);
        leftLeg.position.set(-0.2, -0.4, 0);
        body.add(leftLeg);
        const rightLeg = new THREE.Mesh(legGeo, legMaterial);
        rightLeg.position.set(0.2, -0.4, 0);
        body.add(rightLeg);
        scene.add(body);
        // Увеличенный лабиринт
        const walls = [];
        const wallColor = 0x333333;
        const wallMaterial = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.5, metalness: 0 });
        const wallThin = 1;
        // Внешние стены
        const externalWalls = [
            { geo: new THREE.BoxGeometry(320, 4, wallThin), pos: [0, 2, -150] },
            { geo: new THREE.BoxGeometry(320, 4, wallThin), pos: [0, 2, 150] },
            { geo: new THREE.BoxGeometry(wallThin, 4, 320), pos: [-150, 2, 0] },
            { geo: new THREE.BoxGeometry(wallThin, 4, 320), pos: [150, 2, 0] }
        ];
        externalWalls.forEach(w => {
            const wall = new THREE.Mesh(w.geo, wallMaterial);
            wall.position.set(...w.pos);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        });
        // Внутренние стены
        const wallPositions = [
            [0, 0, -100], [0, 0, 100], [-100, 0, 0], [100, 0, 0],
            [50, 0, -50], [50, 0, 50], [-50, 0, -50], [-50, 0, 50],
            [20, 0, -80], [20, 0, 80], [-20, 0, -80], [-20, 0, 80],
            [80, 0, -20], [80, 0, 20], [-80, 0, -20], [-80, 0, 20],
            [0, 0, -40], [0, 0, 40], [40, 0, 0], [-40, 0, 0],
            [120, 0, -100], [120, 0, 100], [-120, 0, -100], [-120, 0, 100],
            [100, 0, -120], [100, 0, 120], [-100, 0, -120], [-100, 0, 120],
            [30, 0, -60], [30, 0, 60], [-30, 0, -60], [-30, 0, 60],
            [60, 0, -30], [60, 0, 30], [-60, 0, -30], [-60, 0, 30],
            [10, 0, -90], [10, 0, 90], [-10, 0, -90], [-10, 0, 90],
            [90, 0, -10], [90, 0, 10], [-90, 0, -10], [-90, 0, 10],
            [0, 0, -50], [0, 0, 50], [50, 0, 0], [-50, 0, 0],
            [110, 0, -90], [110, 0, 90], [-110, 0, -90], [-110, 0, 90],
            [90, 0, -110], [90, 0, 110], [-90, 0, -110], [-90, 0, 110],
            [70, 0, -40], [70, 0, 40], [-70, 0, -40], [-70, 0, 40],
            [40, 0, -70], [40, 0, 70], [-40, 0, -70], [-40, 0, 70],
            [130, 0, -60], [130, 0, 60], [-130, 0, -60], [-130, 0, 60],
            [60, 0, -130], [60, 0, 130], [-60, 0, -130], [-60, 0, 130]
        ];
        wallPositions.forEach((pos, i) => {
            const lengthIndex = (Math.abs(pos[0]) + Math.abs(pos[2])) % 4;
            const length = 40 + lengthIndex * 20;
            const isHorizontal = Math.abs(pos[0]) >= Math.abs(pos[2]);
            let geo;
            if (isHorizontal) {
                geo = new THREE.BoxGeometry(length, 4, wallThin);
            } else {
                geo = new THREE.BoxGeometry(wallThin, 4, length);
            }
            const wall = new THREE.Mesh(geo, wallMaterial);
            wall.position.set(pos[0], pos[1] + 2, pos[2]);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        });
        // Комната торговца
        const traderRoomWalls = [
            { geo: new THREE.BoxGeometry(20, 4, wallThin), pos: [140, 2, 130] }, // bottom
            { geo: new THREE.BoxGeometry(20, 4, wallThin), pos: [140, 2, 150] }, // top
            { geo: new THREE.BoxGeometry(wallThin, 4, 20), pos: [130, 2, 140] }, // left
            { geo: new THREE.BoxGeometry(wallThin, 4, 10), pos: [150, 2, 135] }, // right partial for door
            { geo: new THREE.BoxGeometry(wallThin, 4, 10), pos: [150, 2, 145] }  // right partial
        ];
        traderRoomWalls.forEach(w => {
            const wall = new THREE.Mesh(w.geo, wallMaterial);
            wall.position.set(...w.pos);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        });
        // Пол
        const floorGeometry = new THREE.PlaneGeometry(400, 400);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        // Монеты
        const coins = [];
        const coinGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const coinMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1, metalness: 1 });
        const coinPositions = [
            [10, 1.5, 10], [-10, 1.5, -10], [30, 1.5, 30], [-30, 1.5, -30],
            [0, 1.5, 80], [80, 1.5, 0], [-80, 1.5, 0], [0, 1.5, -80],
            [100, 1.5, 100], [-100, 1.5, -100], [100, 1.5, -100], [-100, 1.5, 100],
            [50, 1.5, 70], [-50, 1.5, -70], [70, 1.5, -50], [-70, 1.5, 50],
            [120, 1.5, 20], [-120, 1.5, -20], [20, 1.5, 120], [-20, 1.5, -120]
        ];
        coinPositions.forEach(pos => {
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.set(pos[0], pos[1], pos[2]);
            coin.castShadow = true;
            scene.add(coin);
            coins.push(coin);
        });
        // Фрукты
        const fruits = [];
        const fruitGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const fruitMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });
        const fruitPositions = [
            [40, 1.5, 40], [-40, 1.5, -40], [60, 1.5, 60], [-60, 1.5, -60],
            [10, 1.5, 90], [90, 1.5, 10], [-90, 1.5, 10], [10, 1.5, -90],
            [110, 1.5, 110], [-110, 1.5, -110], [110, 1.5, -110], [-110, 1.5, 110]
        ];
        fruitPositions.forEach(pos => {
            const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
            fruit.position.set(pos[0], pos[1], pos[2]);
            fruit.castShadow = true;
            scene.add(fruit);
            fruits.push(fruit);
        });
        // Черные кубики
        const blackCubes = [];
        const blackCubeGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const blackCubeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5, metalness: 0 });
        const blackCubePositions = [
            [15, 1.5, 15], [-15, 1.5, -15], [35, 1.5, 35], [-35, 1.5, -35],
            [5, 1.5, 85], [85, 1.5, 5], [-85, 1.5, 5], [5, 1.5, -85],
            [105, 1.5, 105], [-105, 1.5, -105], [105, 1.5, -105], [-105, 1.5, 105],
            [55, 1.5, 75], [-55, 1.5, -75], [75, 1.5, -55], [-75, 1.5, 55],
            [125, 1.5, 25], [-125, 1.5, -25], [25, 1.5, 125], [-25, 1.5, -125]
        ];
        blackCubePositions.forEach(pos => {
            const cube = new THREE.Mesh(blackCubeGeometry, blackCubeMaterial);
            cube.position.set(pos[0], pos[1], pos[2]);
            cube.castShadow = true;
            scene.add(cube);
            blackCubes.push(cube);
        });
        // Функция для создания реалистичного персонажа
        function createCharacter(color, isEnemy = false) {
            const group = new THREE.Group();
            // Тело
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
            const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0 });
            const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
            bodyMesh.position.y = 0.75;
            group.add(bodyMesh);
            // Голова
            const headGeo = new THREE.SphereGeometry(0.4, 32, 32);
            const headMat = new THREE.MeshStandardMaterial({ color: isEnemy ? 0x333333 : 0xffffff, roughness: 0.5, metalness: 0 });
            const headMesh = new THREE.Mesh(headGeo, headMat);
            headMesh.position.y = 1.75;
            group.add(headMesh);
            // Ноги
            const legGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 32);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0 });
            const leftLegMesh = new THREE.Mesh(legGeo, legMat);
            leftLegMesh.position.set(-0.25, -0.5, 0);
            group.add(leftLegMesh);
            const rightLegMesh = new THREE.Mesh(legGeo, legMat);
            rightLegMesh.position.set(0.25, -0.5, 0);
            group.add(rightLegMesh);
            if (isEnemy) {
                const eyeMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const eyeGeo = new THREE.SphereGeometry(0.05, 16, 16);
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.15, 1.8, 0.3);
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.15, 1.8, 0.3);
                group.add(rightEye);
            }
            group.userData.walkTime = 0;
            group.castShadow = true;
            return group;
        }
        // Враги
        const enemies = [];
        const enemyPositions = [
            [70, 0, 70], [-70, 0, -70], [130, 0, 130], [-130, 0, -130],
            [100, 0, -100], [-100, 0, 100], [140, 0, 50], [-140, 0, -50]
        ];
        enemyPositions.forEach(pos => {
            const enemy = createCharacter(0x880000, true);
            enemy.position.set(pos[0], pos[1] + 1, pos[2]);
            enemy.userData = { hits: 0, lastAttackTime: 0, velocity: new THREE.Vector3(), walkTime: 0 };
            scene.add(enemy);
            enemies.push(enemy);
        });
        // Помощники
        const helpers = [];
        const helperPositions = [
            [50, 0, -100], [-50, 0, 100], [120, 0, -50], [-120, 0, 50],
            [30, 0, -120], [-30, 0, 120], [100, 0, -70], [-100, 0, 70],
            [80, 0, -90], [-80, 0, 90], [140, 0, -30], [-140, 0, 30],
            [60, 0, -110], [-60, 0, 110], [110, 0, -60], [-110, 0, 60]
        ];
        helperPositions.forEach(pos => {
            const helper = createCharacter(0x00ff00);
            helper.position.set(pos[0], pos[1] + 1, pos[2]);
            helper.userData = { velocity: new THREE.Vector3(), greenCubesGiven: 0, superCubeGiven: false, walkTime: 0 };
            scene.add(helper);
            helpers.push(helper);
        });
        // Зеленые кубики
        const greenCubes = [];
        const greenCubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const greenCubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.5, metalness: 0 });
        // Суперкубики
        const superCubes = [];
        const superCubeGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
        const superCubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.1, metalness: 1 });
        // Способности суперкубика
        const superPowers = [
            'fly',
            'invincible',
            'freezeEnemies',
            'highJump'
        ];
        let activePower = null;
        let powerStartTime = 0;
        let freezeStartTime = 0;
        let invincibilityStartTime = 0;
        // Лагерь с торговцем
        const traderPosition = new THREE.Vector3(140, 1, 140);
        const trader = createCharacter(0x0000ff);
        trader.position.copy(traderPosition);
        scene.add(trader);
        // Дверь
        let door = null;
        let doorBox = null;
        const doorPosition = new THREE.Vector3(145, 2, 0);
        // Освещение
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5); // Increased intensity
        scene.add(hemiLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // Increased intensity
        directionalLight.position.set(0, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -200;
        directionalLight.shadow.camera.right = 200;
        directionalLight.shadow.camera.top = 200;
        directionalLight.shadow.camera.bottom = -200;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 400;
        scene.add(directionalLight);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Added ambient light
        scene.add(ambientLight);
        // Проверка столкновений для персонажей
        function characterCollision(newPosition) {
            const charBox = new THREE.Box3().setFromCenterAndSize(
                newPosition,
                new THREE.Vector3(1, 2, 1)
            );
            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (charBox.intersectsBox(wallBox)) {
                    return true;
                }
            }
            return false;
        }
        // Проверка столкновений
        function checkCollision(newPosition) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                newPosition,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) {
                    return true;
                }
            }
            return false;
        }
        // Проверка сбора монет
        function checkCoins() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            coins.forEach((coin, index) => {
                const coinBox = new THREE.Box3().setFromObject(coin);
                if (playerBox.intersectsBox(coinBox)) {
                    scene.remove(coin);
                    coins.splice(index, 1);
                    player.score += 1 * player.coinMultiplier;
                    document.getElementById('score').innerText = player.score;
                }
            });
        }
        // Проверка сбора фруктов
        function checkFruits() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            fruits.forEach((fruit, index) => {
                const fruitBox = new THREE.Box3().setFromObject(fruit);
                if (playerBox.intersectsBox(fruitBox)) {
                    scene.remove(fruit);
                    fruits.splice(index, 1);
                    player.health = Math.min(player.health + 20, 100);
                    document.getElementById('health').innerText = player.health;
                }
            });
        }
        // Проверка сбора зеленых кубиков
        function checkGreenCubes() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            greenCubes.forEach((cube, index) => {
                const cubeBox = new THREE.Box3().setFromObject(cube);
                if (playerBox.intersectsBox(cubeBox)) {
                    scene.remove(cube);
                    greenCubes.splice(index, 1);
                    player.health = Math.min(player.health + 10, 100);
                    document.getElementById('health').innerText = player.health;
                }
            });
        }
        // Проверка сбора суперкубиков
        function checkSuperCubes() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            superCubes.forEach((cube, index) => {
                const cubeBox = new THREE.Box3().setFromObject(cube);
                if (playerBox.intersectsBox(cubeBox)) {
                    scene.remove(cube);
                    superCubes.splice(index, 1);
                    activePower = superPowers[Math.floor(Math.random() * superPowers.length)];
                    powerStartTime = performance.now();
                }
            });
        }
        // Проверка сбора черных кубиков
        function checkBlackCubes() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                camera.position,
                new THREE.Vector3(0.5, 1.5, 0.5)
            );
            blackCubes.forEach((cube, index) => {
                const cubeBox = new THREE.Box3().setFromObject(cube);
                if (playerBox.intersectsBox(cubeBox)) {
                    scene.remove(cube);
                    blackCubes.splice(index, 1);
                    player.blackCollected += 1;
                    document.getElementById('black-ui').innerText = `Черные: ${player.blackCollected}/20`;
                }
            });
        }
        // Логика врагов
        function updateEnemies() {
            const currentTime = performance.now();
            const frozen = activePower === 'freezeEnemies' || (freezeStartTime > 0 && currentTime - freezeStartTime < 10000);
            enemies.forEach((enemy, index) => {
                const distance = camera.position.distanceTo(enemy.position);
                if (distance < 5 && currentTime - enemy.userData.lastAttackTime > 1000) {
                    const invincible = activePower === 'invincible' || (invincibilityStartTime > 0 && currentTime - invincibilityStartTime < 15000);
                    if (!invincible) {
                        player.health -= 10;
                        document.getElementById('health').innerText = player.health;
                    }
                    enemy.userData.hits += 1;
                    enemy.userData.lastAttackTime = currentTime;
                    if (firstDamage) {
                        const randomImage = screamerImages[Math.floor(Math.random() * screamerImages.length)];
                        const screamerImg = document.getElementById('screamer-img');
                        screamerImg.src = randomImage;
                        screamerImg.onerror = () => {
                            console.error('Failed to load screamer image:', randomImage);
                        };
                        document.getElementById('screamer').style.display = 'flex';
                        setTimeout(() => {
                            document.getElementById('screamer').style.display = 'none';
                        }, 500);
                        firstDamage = false;
                    }
                    if (enemy.userData.hits >= 2) {
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                    }
                }
                // Движение врага
                if (!frozen) {
                    let direction = new THREE.Vector3();
                    const chase = player.blackCollected >= 20 || distance < 50;
                    if (chase) {
                        direction.subVectors(camera.position, enemy.position).normalize();
                    } else {
                        direction.x = Math.random() * 2 - 1;
                        direction.z = Math.random() * 2 - 1;
                        direction.normalize();
                    }
                    const speed = player.blackCollected >= 20 ? 0.1 : 0.05;
                    const newPos = enemy.position.clone().add(direction.multiplyScalar(speed));
                    if (!characterCollision(newPos)) {
                        enemy.position.copy(newPos);
                        enemy.userData.walkTime += 0.05;
                        const leftLeg = enemy.children[2];
                        const rightLeg = enemy.children[3];
                        leftLeg.rotation.x = Math.sin(enemy.userData.walkTime) * 0.5;
                        rightLeg.rotation.x = Math.sin(enemy.userData.walkTime + Math.PI) * 0.5;
                        enemy.rotation.y = Math.atan2(direction.x, direction.z);
                    }
                }
            });
        }
        // Логика помощников
        function updateHelpers() {
            helpers.forEach(helper => {
                const distance = camera.position.distanceTo(helper.position);
                if (distance < 10) {
                    if (helper.userData.greenCubesGiven < 3) {
                        const cube = new THREE.Mesh(greenCubeGeometry, greenCubeMaterial);
                        cube.position.copy(camera.position);
                        cube.position.y = 1.5;
                        cube.position.x += Math.random() * 2 - 1;
                        cube.position.z += Math.random() * 2 - 1;
                        scene.add(cube);
                        greenCubes.push(cube);
                        helper.userData.greenCubesGiven += 1;
                    } else if (!helper.userData.superCubeGiven) {
                        const cube = new THREE.Mesh(superCubeGeometry, superCubeMaterial);
                        cube.position.copy(camera.position);
                        cube.position.y = 1.5;
                        cube.position.x += Math.random() * 2 - 1;
                        cube.position.z += Math.random() * 2 - 1;
                        scene.add(cube);
                        superCubes.push(cube);
                        helper.userData.superCubeGiven = true;
                    }
                }
                // Движение помощника
                const direction = new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize();
                const newPos = helper.position.clone().add(direction.multiplyScalar(0.03));
                if (!characterCollision(newPos)) {
                    helper.position.copy(newPos);
                    helper.userData.walkTime += 0.05;
                    const leftLeg = helper.children[2];
                    const rightLeg = helper.children[3];
                    leftLeg.rotation.x = Math.sin(helper.userData.walkTime) * 0.5;
                    rightLeg.rotation.x = Math.sin(helper.userData.walkTime + Math.PI) * 0.5;
                    helper.rotation.y = Math.atan2(direction.x, direction.z);
                }
            });
        }
        // Логика торговца
        function checkTrader() {
            const distance = camera.position.distanceTo(traderPosition);
            if (distance < 5 && keys['KeyE']) {
                document.getElementById('shop').style.display = 'block';
            }
        }
        // Функция покупки
        window.buyItem = function(item) {
            let cost = 0;
            switch (item) {
                case 'improvedFlashlight':
                    cost = 3;
                    if (player.blackCollected >= cost) {
                        player.blackCollected -= cost;
                        player.flashlightLevel += 1;
                        updateFlashlight();
                    }
                    break;
                case 'powerDuration':
                    cost = 2;
                    if (player.blackCollected >= cost) {
                        player.blackCollected -= cost;
                        player.powerDuration += 5000;
                    }
                    break;
                case 'boots2':
                    cost = 3;
                    if (player.blackCollected >= cost && player.bootsLevel === 0) {
                        player.blackCollected -= cost;
                        player.bootsLevel = 1;
                        player.speed = 0.7;
                    }
                    break;
                case 'boots3':
                    cost = 4;
                    if (player.blackCollected >= cost && player.bootsLevel === 1) {
                        player.blackCollected -= cost;
                        player.bootsLevel = 2;
                        player.speed = 1.0;
                    }
                    break;
                case 'superBoots':
                    cost = 7;
                    if (player.blackCollected >= cost && player.bootsLevel === 2) {
                        player.blackCollected -= cost;
                        player.bootsLevel = 3;
                        player.speed = 1.5;
                    }
                    break;
                case 'randomPower':
                    cost = 3;
                    if (player.blackCollected >= cost) {
                        player.blackCollected -= cost;
                        activePower = superPowers[Math.floor(Math.random() * superPowers.length)];
                        powerStartTime = performance.now();
                    }
                    break;
                case 'healthPotion':
                    cost = 2;
                    if (player.blackCollected >= cost) {
                        player.blackCollected -= cost;
                        player.health = Math.min(player.health + 50, 100);
                        document.getElementById('health').innerText = player.health;
                    }
                    break;
                case 'freezePotion':
                    cost = 4;
                    if (player.blackCollected >= cost) {
                        player.blackCollected -= cost;
                        freezeStartTime = performance.now();
                    }
                    break;
                case 'coinMultiplier':
                    cost = 3;
                    if (player.blackCollected >= cost) {
                        player.blackCollected -= cost;
                        player.coinMultiplier = 2;
                        player.coinMultiplierStart = performance.now();
                    }
                    break;
                case 'invincibilityPotion':
                    cost = 5;
                    if (player.blackCollected >= cost) {
                        player.blackCollected -= cost;
                        invincibilityStartTime = performance.now();
                    }
                    break;
            }
            document.getElementById('black-ui').innerText = `Черные: ${player.blackCollected}/20`;
        };
        // Закрытие магазина
        document.getElementById('close-shop').addEventListener('click', () => {
            document.getElementById('shop').style.display = 'none';
        });
        // Обновление способностей
        function updatePowers() {
            const currentTime = performance.now();
            if (activePower && currentTime < powerStartTime + player.powerDuration) {
                const remaining = Math.ceil((powerStartTime + player.powerDuration - currentTime) / 1000);
                document.getElementById('power-ui').innerText = `${activePower} (${remaining}s)`;
            } else {
                activePower = null;
                document.getElementById('power-ui').innerText = '';
            }
            if (player.coinMultiplier > 1 && currentTime > player.coinMultiplierStart + 30000) {
                player.coinMultiplier = 1;
            }
        }
        // Создание двери
        function createDoor() {
            const doorGroup = new THREE.Group();
            const doorGeo = new THREE.BoxGeometry(0.1, 4, 5);
            const doorMesh = new THREE.Mesh(doorGeo, new THREE.MeshStandardMaterial({ color: 0x000000 }));
            doorGroup.add(doorMesh);
            const edges = new THREE.EdgesGeometry(doorGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
            doorGroup.add(line);
            doorGroup.position.copy(doorPosition);
            scene.add(doorGroup);
            doorBox = new THREE.Box3().setFromObject(doorGroup);
            return doorGroup;
        }
        // Игровой цикл
        function animate() {
            requestAnimationFrame(animate);
            // Обновление чувствительности мыши
            mouseSensitivity = parseFloat(mouseSensitivitySlider.value);
            // Обновление способностей
            updatePowers();
            // Движение игрока
            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;
            // Гравитация и полет
            if (activePower === 'fly') {
                player.velocity.y = 0;
                if (keys['Space']) player.velocity.y += player.speed;
                if (keys['ShiftLeft']) player.velocity.y -= player.speed;
            } else {
                player.velocity.y -= 0.005;
            }
            let moving = false;
            if (direction.length() > 0) {
                direction.normalize();
                direction.applyQuaternion(camera.quaternion);
                if (activePower !== 'fly') direction.y = 0;
                moving = true;
                walkTime += 0.05;
                body.rotation.y = Math.atan2(direction.x, direction.z);
            }
            // Прыжок
            let jumpHeight = 0.2;
            if (activePower === 'highJump') jumpHeight = 0.4;
            if (keys['Space'] && onGround && activePower !== 'fly') {
                player.velocity.y = jumpHeight;
                onGround = false;
            }
            const newPosition = camera.position.clone().add(direction.multiplyScalar(player.speed));
            newPosition.y += player.velocity.y;
            if (!checkCollision(newPosition)) {
                camera.position.copy(newPosition);
            }
            if (camera.position.y <= 1.5 && activePower !== 'fly') {
                camera.position.y = 1.5;
                player.velocity.y = 0;
                onGround = true;
            }
            // Анимация ног и покачивание головы
            leftLeg.rotation.x = Math.sin(walkTime) * 0.5;
            rightLeg.rotation.x = Math.sin(walkTime + Math.PI) * 0.5;
            camera.position.y += Math.sin(walkTime) * 0.05;
            // Обновление позиции тела
            body.position.copy(camera.position);
            body.position.y -= 0.7;
            if (!moving) {
                body.rotation.y = camera.rotation.y;
            }
            // Вращение монет
            coins.forEach(coin => {
                coin.rotation.y += 0.01;
            });
            // Проверки сбора
            checkCoins();
            checkFruits();
            checkGreenCubes();
            checkSuperCubes();
            checkBlackCubes();
            // Создание двери
            if (player.blackCollected === 20 && !door) {
                door = createDoor();
            }
            // Обновление врагов и помощников
            updateEnemies();
            updateHelpers();
            // Проверка торговца
            checkTrader();
            // Проверка здоровья
            if (player.health <= 0) {
                document.getElementById('ui').innerText = 'Игра окончена! Счёт: ' + player.score;
            }
            // Проверка входа в дверь
            if (door) {
                const playerBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(0.5, 1.5, 0.5));
                if (playerBox.intersectsBox(doorBox)) {
                    document.getElementById('ui').innerText = 'Вы выиграли! Вошли в дверь!';
                }
            }
            renderer.render(scene, camera);
        }
        // Обработка изменения размера окна
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // Обработка ориентации для мобильных устройств
        function checkOrientation() {
            const rotateMessage = document.getElementById('rotate-message');
            if (window.innerHeight > window.innerWidth) {
                rotateMessage.style.display = 'block';
            } else {
                rotateMessage.style.display = 'none';
            }
        }
        window.addEventListener('orientationchange', checkOrientation);
        window.addEventListener('resize', checkOrientation);
        checkOrientation();
        // Запуск игры
        camera.position.set(0, 1.5, 0);
        animate();
    </script>
</body>
</html>
